use core::{cmp::Ordering, str::FromStr};

use bxcan::{Frame, StandardId};
use embedded_sdmmc::{self as sdmmc, ShortFileName};
use heapless::{String, Vec};
use rtic_monotonics::Monotonic;
use stm32f1xx_hal::gpio::{Alternate, Pin};

use crate::{app::Mono, render::formatted_string, spi::*};

/// Length in bytes of CAN logs lines generated by [`frame_to_log()`].
///
/// **WARNING**: if the length is too short, all calls to [`frame_to_log()`] will panic due to a
/// buffer overflow of the generated log line. Don't forget to count the ending `\n` in the buffer
/// length.
const LOG_LINE_LEN: usize = 46;
/// Size in bytes of the read buffer of [`CanLogsIterator`]s.
///
/// Log files will be read by chunks of [`READ_BUFFER_SIZE`] bytes. To help reduce use of expensive
/// SD card reads, make sure that the buffer is at least large enough to fit the expect log lines
/// in length. A too short buffer will result in more SD reads than necessary.
const READ_BUFFER_SIZE: usize = 64;
/// Size in bytes of the store buffer of [`CanLogsIterator`]s.
///
/// See the documentation for the [`CanLogsIterator::stored`] field for use case.
///
/// The store buffer must be at least as large as the read buffer, otherwise a compile-time error
/// will be thrown.
const STORE_BUFFER_SIZE: usize = READ_BUFFER_SIZE * 3;
const _: () = assert!(
    STORE_BUFFER_SIZE >= READ_BUFFER_SIZE,
    "The store buffer must be at least as large as the read buffer"
);

/// Type alias for the [`embedded_sdmmc::SdCard`].
pub type SdCard = sdmmc::SdCard<
    SpiWrapper<(
        Pin<'B', 13, Alternate>,
        Pin<'B', 14>,
        Pin<'B', 15, Alternate>,
    )>,
    OutputPinWrapper<'B', 12>,
    Mono,
>;
/// Type alias for the [`embedded_sdmmc::VolumeManager`].
pub type VolumeManager = sdmmc::VolumeManager<SdCard, FakeTimeSource, 2, 2>;
/// Type alias for the [`embedded_sdmmc::Directory`].
pub type Directory<'a> = sdmmc::Directory<'a, SdCard, FakeTimeSource, 2, 2, 1>;
/// Type alias for the [`embedded_sdmmc::File`].
pub type File<'a> = sdmmc::File<'a, SdCard, FakeTimeSource, 2, 2, 1>;

/// Decodes a string of up to 8 bytes in hexadecimal into a [`Vec<u8>`].
///
/// `s` can only contain characters `0-9a-zA-Z`. If `s` contains an uneven number of characters,
/// the last character will be ignored. If `s` contains more than 8 bytes, remaining bytes will be
/// ignored.
///
/// Returns an [`Err<()>`] in case of parsing error.
pub fn decode_hex(s: &str) -> Result<Vec<u8, 8>, ()> {
    if s.len() % 2 != 0 {
        Err(())
    } else {
        (0..s.len())
            .step_by(2)
            .map(|i| u8::from_str_radix(&s[i..i + 2], 16).map_err(|_| ()))
            .collect()
    }
}

/// An iterator over CAN frames contained in a log file.
///
/// See [`CanLogsIterator::next()`] for parsing details.
pub struct CanLogsIterator<'a> {
    /// The owned [`File`] that will be scanned for CAN frames.
    log_file: File<'a>,
    /// A buffer containing file reads artefacts.
    ///
    /// The [`log_file`][CanLogsIterator::log_file] will be read in chunk of size
    /// [`READ_BUFFER_SIZE`] into [`stored`][CanLogsIterator::stored].
    /// [`stored`][CanLogsIterator::stored] will then get parsed to extract the contained CAN
    /// frames.
    stored: String<STORE_BUFFER_SIZE>,
}

impl<'a> CanLogsIterator<'a> {
    /// Creates a new [`CanLogsIterator`] from a given [`File`].
    pub fn new(log_file: File<'a>) -> Self {
        Self {
            log_file,
            stored: String::new(),
        }
    }
}

impl Iterator for CanLogsIterator<'_> {
    type Item = Frame;

    /// Reads the next [`Frame`] from the [`log_file`][CanLogsIterator::log_file].
    ///
    /// This is done by first loading a chunk of the [`log_file`][CanLogsIterator::log_file] into
    /// the [`stored`][CanLogsIterator::stored] buffer. We then try to extract a line from the
    /// buffer, if no line feed (`\n`) is found, the read operation is repeated if enough space in
    /// the buffer is left.
    ///
    /// The extracted line is then parsed with a logic equivalent to the following regex :
    /// `/.* ([0-9A-F]{3})#([0-9A-F]{16})\n/i`. This is done by grabbing anything after the last
    /// space (` `) in the line and extracting the [`Frame`] id and data.
    ///
    /// If any error is encountered while reading the file, [`None`] is returned and iteration ends.
    /// If any error occurs during parsing, [`None`] is returned and iteration ends (this behavior
    /// should be changed).
    ///
    /// # To-Do
    /// - [ ] Replace errors marked with `!?` in source with a line skip instead of an iteration
    ///      end. *(Errors marked `?` are irrecoverable and already well handled.)*
    /// - [ ] Improve line parsing to allow lines longer than [`STORE_BUFFER_SIZE`].
    /// - [ ] Improve line parsing to allow frames with payloads shorter than 8 bytes.
    /// - [ ] Make sure the `stored` buffer is consumed even after EOF is reached.
    fn next(&mut self) -> Option<Self::Item> {
        while !self.log_file.is_eof() {
            if STORE_BUFFER_SIZE - self.stored.len() >= READ_BUFFER_SIZE {
                let mut buffer = [0u8; READ_BUFFER_SIZE];
                let read_count = self.log_file.read(&mut buffer).ok()?; // ? Read error
                self.stored
                    .push_str(core::str::from_utf8(&buffer[..read_count]).ok()?) // ? utf-8 char got split
                    .expect("it fits");
            }

            let new_line_i = self.stored.find("\n");
            if let None = new_line_i {
                if STORE_BUFFER_SIZE - self.stored.len() >= READ_BUFFER_SIZE {
                    continue;
                } else {
                    break;
                }
            }
            let new_line_i = new_line_i.expect("some");
            let stored_clone = self.stored.clone();

            let log_line = &stored_clone[..new_line_i];
            self.stored = String::from_str(&stored_clone[new_line_i + 1..]).expect("it fits");

            if log_line.starts_with('#') {
                continue; // skip comment lines
            }

            let mut frame_bytes = log_line.split(" ").last()?.split("#"); // ? Infaillible
            let frame_id = u16::from_str_radix(frame_bytes.next()?, 16).ok()?; // !? frame_bytes doesn't have >= 1 elements || !? invalid hexadecimal
            let frame_data = decode_hex(frame_bytes.next()?).ok()?; // !? frame_bytes doesn't have >= 2 elements || !? invalid hexadecimal

            return Some(Frame::new_data(
                StandardId::new(frame_id)?,         // !? frame_id doesn't fit in 11 bits
                frame_data.into_array::<8>().ok()?, // !? frame_data didn't contain 8 bytes
            ));
        }
        None
    }
}

/// Formats a given [`Frame`] as a log line.
///
/// If the frame doesn't have a full 8 bytes payload, padding in the form of `FF` will be used.
///
/// Format is as follows :
/// ```logs
/// (0000375767.000000) can0 001#0123456789ABCDEF
///  ^^^^^^^^^┤         ^^^┤ ^^┤ ^^^^^^^^^^^^^^^┴─ 8-byte hexadecimal frame payload
///           │            │   └─ 11-bit hexadecimal identifier
///           │            └─ Can Interface - always can0
///           └─ Time of capture (in ticks since boot)
/// ```
pub fn frame_to_log(frame: &Frame) -> String<LOG_LINE_LEN> {
    let _empty = bxcan::Data::empty();
    let frame_data = frame.data().unwrap_or(&_empty);

    formatted_string::<LOG_LINE_LEN>(format_args!(
        "({:010}.000000) can0 {:03X}#{:02X}{:02X}{:02X}{:02X}{:02X}{:02X}{:02X}{:02X}\n",
        Mono::now().ticks(),
        match frame.id() {
            bxcan::Id::Standard(n) => n.as_raw() as u32,
            bxcan::Id::Extended(n) => n.as_raw(),
        },
        frame_data.get(0).unwrap_or(&0xFF),
        frame_data.get(1).unwrap_or(&0xFF),
        frame_data.get(2).unwrap_or(&0xFF),
        frame_data.get(3).unwrap_or(&0xFF),
        frame_data.get(4).unwrap_or(&0xFF),
        frame_data.get(5).unwrap_or(&0xFF),
        frame_data.get(6).unwrap_or(&0xFF),
        frame_data.get(7).unwrap_or(&0xFF),
    ))
    .expect("frame should fit in line")
}

/// Indexes the content of `dir` into the provided `content` [`Vec`].
///
/// The contents of `dir` will be indexed as pairs of `(is_directory: bool, item_name:
/// ShortFileName)`. The items will be sorted with directories first and then by alphabetical
/// order. If the provided [`Vec`] is too small, `content` will ony contain the first items that
/// could fit. If `content` already contains items, newly indexed items will be merged with already
/// present ones.
///
/// If `dirs_only` is `true`, files will no be indexed and the current directory (`.`) will be
/// part of the index. In any case, if `dir` is not a root directory, the index will contain the
/// parent directory (`..`).
///
/// Returns [`Err`] in case of [`sdmmc::SdCardError`].
///
/// # To-Do
/// - [ ] Handle edge case of trying to add `.` to a full `content`.
pub fn index_dir<const N: usize>(
    dir: &mut Directory,
    content: &mut Vec<(bool, ShortFileName), N>,
    dirs_only: bool,
) -> Result<(), sdmmc::Error<sdmmc::SdCardError>> {
    // Iterator over the directory's entries with a closure
    dir.iterate_dir(|e| {
        // Skip files if `dirs_only`
        if dirs_only && !e.attributes.is_directory() {
            return;
        }

        // Take ownership and skip `.` if not `dirs_only`
        let e = (e.attributes.is_directory(), e.name.clone());
        if !dirs_only && e == (true, ShortFileName::this_dir()) {
            return;
        }

        // Sorted insert into `content` using a bubble sort-like algorithm
        let mut i = 0;
        while i < content.len() {
            // Match type flags (`is_directory`)
            if match (content[i].0, e.0) {
                // Items have different types (file and dir) => manual ordering
                (false, true) => Ordering::Greater,
                (true, false) => Ordering::Less,
                // Items have same type (both files or dirs) => alphabetical sorting
                _ => core::str::from_utf8(content[i].1.base_name())
                    .unwrap_or("")
                    .cmp(core::str::from_utf8(e.1.base_name()).unwrap_or("")),
            }
            .is_ge()
            {
                break;
            }
            i += 1;
        }
        // Insert at sorted index, ignoring if the vector if full thus dropping overflowing items
        let _ = content.insert(i, e);
    })?;

    // If nothing was found in `dir`, `.` is added
    if content.is_empty() || (dirs_only && !content.contains(&(true, ShortFileName::this_dir()))) {
        content
            .insert(0, (true, ShortFileName::this_dir()))
            .expect("there is space"); // TODO : handle edge case : content.is_full()
    }

    Ok(())
}
