use core::{
    fmt::{Arguments, Write},
    str::FromStr,
};

use embedded_graphics::{
    geometry::AnchorX,
    image::Image,
    mono_font::{
        ascii::{FONT_5X7, FONT_6X12, FONT_6X13_BOLD},
        MonoTextStyle, MonoTextStyleBuilder,
    },
    pixelcolor::BinaryColor,
    prelude::*,
    primitives::{
        CornerRadii, PrimitiveStyle, PrimitiveStyleBuilder, Rectangle, RoundedRectangle,
        StrokeAlignment, StyledDrawable,
    },
    text::{Alignment, Baseline, Text, TextStyle, TextStyleBuilder},
};
use embedded_sdmmc::ShortFileName;
use heapless::String;
use ssd1306::{
    mode::BufferedGraphicsMode, prelude::I2CInterface, size::DisplaySize128x64, Ssd1306,
};
use stm32f1xx_hal::{
    gpio::{Alternate, OpenDrain, Pin},
    i2c::BlockingI2c,
    pac::I2C1,
};
use tinybmp::Bmp;

use crate::{
    can::{Bitrate, EmissionMode},
    state::{EmissionSettingsItem, HomeItem},
};

/// Type alias for the display driver
pub type Display = Ssd1306<
    I2CInterface<
        BlockingI2c<
            I2C1,
            (
                Pin<'B', 6, Alternate<OpenDrain>>,
                Pin<'B', 7, Alternate<OpenDrain>>,
            ),
        >,
    >,
    DisplaySize128x64,
    BufferedGraphicsMode<DisplaySize128x64>,
>;

/// Width of used display
const DISPLAY_WIDTH: u32 = 128;
/// Height of used display
const DISPLAY_HEIGHT: u32 = 64;

/// Bottom Y coordinate of first text line
pub const TEXT_LINE_1: i32 = 1 * 12 - 1;
/// Bottom Y coordinate of second text line
pub const TEXT_LINE_2: i32 = 2 * 12 + 0;
/// Bottom Y coordinate of third text line
pub const TEXT_LINE_3: i32 = 3 * 12 + 1;
/// Bottom Y coordinate of fourth text line
pub const TEXT_LINE_4: i32 = 4 * 12 + 2;
/// Bottom Y coordinate of fifth text line
pub const TEXT_LINE_5: i32 = 5 * 12 + 3;

/// Default text style
static DEFAULT_TEXT_STYLE: MonoTextStyle<BinaryColor> = MonoTextStyleBuilder::new()
    .font(&FONT_6X12)
    .text_color(BinaryColor::On)
    .background_color(BinaryColor::Off)
    .build();
/// Highlighted text style (underlined)
static HIGHLIGHTED_TEXT_STYLE: MonoTextStyle<BinaryColor> = MonoTextStyleBuilder::new()
    .font(&FONT_6X12)
    .text_color(BinaryColor::On)
    .background_color(BinaryColor::Off)
    .underline()
    .build();
/// Title text style (bold and color-inverted)
static TITLE_TEXT_STYLE: MonoTextStyle<BinaryColor> = MonoTextStyleBuilder::new()
    .font(&FONT_6X13_BOLD)
    .text_color(BinaryColor::Off)
    .background_color(BinaryColor::On)
    .build();
/// Header text style (color-inverted)
static HEADER_TEXT_STYLE: MonoTextStyle<BinaryColor> = MonoTextStyleBuilder::new()
    .font(&FONT_6X12)
    .text_color(BinaryColor::Off)
    .background_color(BinaryColor::On)
    .build();
/// Small text style (5x7 instead of 6x12)
static SMALL_TEXT_STYLE: MonoTextStyle<BinaryColor> = MonoTextStyleBuilder::new()
    .font(&FONT_5X7)
    .text_color(BinaryColor::On)
    .background_color(BinaryColor::Off)
    .build();

/// Center-middle text alignement
static CENTER_MIDDLE: TextStyle = TextStyleBuilder::new()
    .alignment(Alignment::Center)
    .baseline(Baseline::Middle)
    .build();
/// Center-bottom text alignement
static CENTER_BOTTOM: TextStyle = TextStyleBuilder::new()
    .alignment(Alignment::Center)
    .baseline(Baseline::Bottom)
    .build();
/// Left bottom text alignement
static LEFT_BOTTOM: TextStyle = TextStyleBuilder::new()
    .alignment(Alignment::Left)
    .baseline(Baseline::Bottom)
    .build();
/// Right-bottom text alignement
static RIGHT_BOTTOM: TextStyle = TextStyleBuilder::new()
    .alignment(Alignment::Right)
    .baseline(Baseline::Bottom)
    .build();

/// Default line stroke
static DEFAULT_STROKE: PrimitiveStyle<BinaryColor> = PrimitiveStyleBuilder::new()
    .stroke_color(BinaryColor::On)
    .stroke_width(1)
    .stroke_alignment(StrokeAlignment::Inside)
    .build();
/// Highlighted line stroke (wider)
static HIGHLIGHTED_STROKE: PrimitiveStyle<BinaryColor> = PrimitiveStyleBuilder::new()
    .stroke_color(BinaryColor::On)
    .stroke_width(2)
    .stroke_alignment(StrokeAlignment::Inside)
    .build();

/// Returns an owned [`String<N>`] created from some [`Arguments`] generated by the
/// [`format_args!`] macro.
///
/// The `N` type parameter defines the capacity of the returned [`String`]. Allocating too little
/// will return a [`core::fmt::Error`].
///
/// # To-Do
/// - [ ] Replace with a `marco_rules!` to improve calls readability.
pub fn formatted_string<const N: usize>(
    args: Arguments<'_>,
) -> Result<String<N>, core::fmt::Error> {
    let mut string = String::new();

    string.write_fmt(args)?;

    Ok(string)
}

/// Takes ownership of a [`String`], makes its ASCII characters lowercase and returns ownership
/// to it.
///
/// Ownership is temporarily taken to make use in conjunction with [`formatted_string()`] easier.
pub fn to_ascii_lowercase<const N: usize>(mut string: String<N>) -> String<N> {
    string.make_ascii_lowercase();

    string
}

/// Draws a header containing `header` to the provided `display`.
///
/// If `is_title` is `true`, the header will be drawn with the [`TITLE_TEXT_STYLE`], otherwise it
/// will be drawn with the [`HEADER_TEXT_STYLE`].
///
/// The header is always drawn centered on [`TEXT_LINE_1`].
pub fn draw_header(display: &mut Display, header: &str, is_title: bool) {
    let text = Text::with_text_style(
        header,
        Point::new((DISPLAY_WIDTH / 2) as i32, TEXT_LINE_1),
        if is_title {
            TITLE_TEXT_STYLE
        } else {
            HEADER_TEXT_STYLE
        },
        CENTER_BOTTOM,
    );
    let _ = text
        .bounding_box()
        .resized_width(DISPLAY_WIDTH + 2, AnchorX::Center)
        .into_styled(PrimitiveStyle::with_fill(
            text.character_style.background_color.unwrap_or_default(),
        ))
        .draw(display);
    let _ = text.draw(display);
}

/// Draws `text` aligned [`LEFT_BOTTOM`] on `line` and flushes the screen.
///
/// Used to display boot progress during [`init()`][crate::app::init].
pub fn flush_text_line(display: &mut Display, text: &str, line: i32) {
    let _ = Text::with_text_style(text, Point::new(0, line), DEFAULT_TEXT_STYLE, LEFT_BOTTOM)
        .draw(display);
    let _ = display.flush();
}

/// Draws a hint for function of LEFT button on provided `display`.
fn draw_left_hint(display: &mut Display, hint: &str) {
    let text_hint = Text::with_text_style(
        hint,
        Point::new(7, (DISPLAY_HEIGHT - 1) as i32),
        DEFAULT_TEXT_STYLE,
        LEFT_BOTTOM,
    );
    let hint_outline = RoundedRectangle::new(
        Rectangle::new(
            text_hint.bounding_box().top_left - Point::new(9, 1),
            text_hint.bounding_box().size + Size::new(9 + 2, 1 + 2),
        ),
        CornerRadii::new(Size::new_equal(4)),
    );

    let _ = Image::new(
        &Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/left.bmp")).unwrap(),
        Point::new(0, DISPLAY_HEIGHT as i32 - 12),
    )
    .draw(display);
    let _ = text_hint.draw(display);
    let _ = hint_outline.draw_styled(&DEFAULT_STROKE, display);
}
/// Draws a hint for function of RIGHT button on provided `display`.
fn draw_right_hint(display: &mut Display, hint: &str) {
    let text_hint = Text::with_text_style(
        hint,
        Point::new((DISPLAY_WIDTH - 8) as i32, (DISPLAY_HEIGHT - 1) as i32),
        DEFAULT_TEXT_STYLE,
        RIGHT_BOTTOM,
    );
    let hint_outline = RoundedRectangle::new(
        Rectangle::new(
            text_hint.bounding_box().top_left - Point::new(3, 1),
            text_hint.bounding_box().size + Size::new(3 + 9, 1 + 2),
        ),
        CornerRadii::new(Size::new_equal(4)),
    );

    let _ = Image::new(
        &Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/right.bmp")).unwrap(),
        Point::new(DISPLAY_WIDTH as i32 - 7, DISPLAY_HEIGHT as i32 - 12),
    )
    .draw(display);
    let _ = text_hint.draw(display);
    let _ = hint_outline.draw_styled(&DEFAULT_STROKE, display);
}
/// Draws a hint for function of OK button on provided `display`.
///
/// The `x_displacement` parameter allows to nudge the hint on the X axis to help avoid collisions
/// with other hints.
fn draw_center_hint(display: &mut Display, hint: &str, x_displacement: i32) {
    let text_hint = Text::with_text_style(
        hint,
        Point::new(
            (DISPLAY_WIDTH / 2 + 3) as i32 + x_displacement,
            (DISPLAY_HEIGHT - 1) as i32,
        ),
        DEFAULT_TEXT_STYLE,
        CENTER_BOTTOM,
    );
    let hint_outline = RoundedRectangle::new(
        Rectangle::new(
            text_hint.bounding_box().top_left - Point::new(7 + 2, 1),
            text_hint.bounding_box().size + Size::new((7 + 2) + 2, 1 + 2),
        ),
        CornerRadii::new(Size::new_equal(4)),
    );

    let _ = Image::new(
        &Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/ok.bmp")).unwrap(),
        Point::new(
            text_hint.bounding_box().top_left.x - 7,
            DISPLAY_HEIGHT as i32 - 12,
        ),
    )
    .draw(display);
    let _ = text_hint.draw(display);
    let _ = hint_outline.draw_styled(&DEFAULT_STROKE, display);
}

/// Draws home screen on provided `display`.
///
/// The `selected_item` tells which [HomeItem] should be drawn as selected.
pub fn draw_home(display: &mut Display, selected_item: &HomeItem) {
    // Load icons
    let emit_icon = Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/emit.bmp")).unwrap();
    let capture_icon =
        Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/capture.bmp")).unwrap();

    draw_header(
        display,
        concat!("CANary v", env!("CARGO_PKG_VERSION")),
        true,
    );

    // Common parameters
    let emit_button_pos = Point::new((DISPLAY_WIDTH / 4) as i32, 37);
    let capt_button_pos = Point::new((DISPLAY_WIDTH / 4 * 3) as i32, 37);
    let home_button_size = Size::new(48, 48);
    let (emit_styles, capt_styles) = match selected_item {
        HomeItem::Emit => (
            (&HIGHLIGHTED_STROKE, HIGHLIGHTED_TEXT_STYLE),
            (&DEFAULT_STROKE, DEFAULT_TEXT_STYLE),
        ),
        HomeItem::Capture => (
            (&DEFAULT_STROKE, DEFAULT_TEXT_STYLE),
            (&HIGHLIGHTED_STROKE, HIGHLIGHTED_TEXT_STYLE),
        ),
    };

    // Draw "Emit" button
    let _ = RoundedRectangle::new(
        Rectangle::with_center(emit_button_pos, home_button_size),
        CornerRadii::new(Size::new_equal(8)),
    )
    .draw_styled(emit_styles.0, display);
    let _ = Text::with_text_style(
        "Emit",
        emit_button_pos + Point::new(0, 6),
        emit_styles.1,
        CENTER_MIDDLE,
    )
    .draw(display);
    let _ = Image::with_center(&emit_icon, emit_button_pos - Point::new(0, 6)).draw(display);

    // Draw "Capture" button
    let _ = RoundedRectangle::new(
        Rectangle::with_center(capt_button_pos, home_button_size),
        CornerRadii::new(Size::new_equal(8)),
    )
    .draw_styled(capt_styles.0, display);
    let _ = Text::with_text_style(
        "Capture",
        capt_button_pos + Point::new(0, 6),
        capt_styles.1,
        CENTER_MIDDLE,
    )
    .draw(display);
    let _ = Image::with_center(&capture_icon, capt_button_pos - Point::new(0, 6)).draw(display);
}

/// Draws a file/directory selection screen on provided `display`.
///
/// If `current_dir` is [`Some<&ShortFileName>`], the [`ShortFileName`] is displayed as a header,
/// otherwise `root` is displayed in the header.
///
/// The `content` is the list of files and directories to selected from in format `(is_directory:
/// bool, item_name: ShortFileName)` and `selected_index` is the index of the currently selected
/// item (will be highlighted).
pub fn draw_file_selection(
    display: &mut Display,
    current_dir: Option<&ShortFileName>,
    content: &[(bool, ShortFileName)],
    selected_index: usize,
) {
    // Load icons
    let file_icon = Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/file.bmp")).unwrap();
    let dir_icon = Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/directory.bmp")).unwrap();
    let selected_icon =
        Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/chevron_right.bmp")).unwrap();
    let scroll_icon =
        Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/chevrons_vertical.bmp")).unwrap();

    // Draw header
    let dir_str: String<16> = if let Some(current_dir) = current_dir {
        to_ascii_lowercase(
            formatted_string(format_args!("{}", current_dir)).expect("ShortFileNames.len() <= 12"),
        )
    } else {
        String::from_str("root").expect("\"root\".len() == 4")
    };
    draw_header(display, &dir_str, false);

    // Draw hints
    draw_left_hint(display, "back");
    draw_center_hint(display, "select", -4);
    draw_right_hint(display, "enter");

    // Check content length
    if content.len() == 0 {
        return;
    }
    if content.len() > 3 {
        let _ = Image::new(
            &scroll_icon,
            Point::new(DISPLAY_WIDTH as i32 - 12, TEXT_LINE_3 - 11),
        )
        .draw(display);
    }

    // Choose entries to display and line to highlight
    let (content, highlighted_line) = match selected_index {
        0 => (&content[0..=2.min(content.len() - 1)], 0), // Show first entries and highlight 1st line
        n if content.len() <= 3 => (content, n), // Show all entries and highlight selected line
        n if n == content.len() - 1 => (&content[content.len() - 3..content.len()], 2), // Show last entries and highlight last line
        n => (&content[n - 1..=n + 1], 1), // Show entries adjacent to selected one and highlight center line
    };

    // Draw selected entries
    for (i, (is_dir, name)) in content.iter().enumerate() {
        let _ = Image::new(
            if i == highlighted_line as usize {
                &selected_icon
            } else if *is_dir {
                &dir_icon
            } else {
                &file_icon
            },
            Point::new(0, TEXT_LINE_2 + 13 * i as i32 - 11),
        )
        .draw(display);

        let _ = Text::with_text_style(
            &to_ascii_lowercase(formatted_string::<16>(format_args!("{}", name)).unwrap()),
            Point::new(13, TEXT_LINE_2 + 13 * i as i32),
            if i == highlighted_line as usize {
                HIGHLIGHTED_TEXT_STYLE
            } else {
                DEFAULT_TEXT_STYLE
            },
            LEFT_BOTTOM,
        )
        .draw(display);
    }
}

/// Draws the emission screen to the provided `display`.
///
/// Other parameters are from the current [`State`][crate::state::State] and used for display.
pub fn draw_emission(
    display: &mut Display,
    selected: &ShortFileName,
    running: bool,
    count: u8,
    bitrate: &Bitrate,
    mode: &EmissionMode,
    success_count: u32,
) {
    // Load icons
    let emit_icon = Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/emit.bmp")).unwrap();
    let scroll_icon =
        Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/chevrons_vertical.bmp")).unwrap();
    let play_icon = Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/play.bmp")).unwrap();
    let pause_icon = Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/pause.bmp")).unwrap();
    let stop_icon = Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/stop.bmp")).unwrap();

    // Draw header and header icon
    draw_header(
        display,
        &to_ascii_lowercase(formatted_string::<16>(format_args!("{}", selected)).unwrap()),
        false,
    );
    let _ = Image::new(&emit_icon, Point::zero()).draw(display);

    // Draw hints
    if running {
        draw_center_hint(display, "Stop", -4);
    } else {
        draw_left_hint(display, "Exit");
        draw_center_hint(display, "Start", -7);
        draw_right_hint(display, "Params");
    }

    // Load emission parameters
    let count_str: String<14> = if count == 0 {
        String::from_str("Repeating xINF").unwrap()
    } else {
        formatted_string(format_args!("Repeating x{:->3}", count)).unwrap()
    };
    let bitrate_str: String<17> =
        formatted_string(format_args!("Bitrate: {:4}kbps", *bitrate as u32 / 1000)).unwrap();
    let mode_str: String<15> = formatted_string(format_args!("Mode: {:?}", mode)).unwrap();

    // Draw emission parameters
    let _ = Image::new(&scroll_icon, Point::new(5 * 14 - 2, TEXT_LINE_2 - 10)).draw(display);
    let _ = Text::with_text_style(
        &count_str,
        Point::new(0, TEXT_LINE_2),
        SMALL_TEXT_STYLE,
        LEFT_BOTTOM,
    )
    .draw(display);
    let _ = Text::with_text_style(
        &bitrate_str,
        Point::new(0, TEXT_LINE_3),
        SMALL_TEXT_STYLE,
        LEFT_BOTTOM,
    )
    .draw(display);
    let _ = Text::with_text_style(
        &mode_str,
        Point::new(0, TEXT_LINE_3 + 8),
        SMALL_TEXT_STYLE,
        LEFT_BOTTOM,
    )
    .draw(display);

    // Draw emission state icon
    let _ = Image::new(
        if running {
            &pause_icon
        } else if success_count == 0 {
            &play_icon
        } else {
            &stop_icon
        },
        Point::new(DISPLAY_WIDTH as i32 - 16 - 12, 18),
    )
    .draw(display);

    // Draw emission state text
    let state_str: String<16> = if running {
        String::from_str("Running").unwrap()
    } else if success_count == 0 {
        String::from_str("Standby").unwrap()
    } else {
        formatted_string(format_args!("Sent {}\nframes", success_count % 10000)).unwrap()
    };
    let _ = Text::with_text_style(
        &state_str,
        Point::new(DISPLAY_WIDTH as i32 - 16 / 2 - 12, TEXT_LINE_3 + 4),
        SMALL_TEXT_STYLE,
        CENTER_BOTTOM,
    )
    .draw(display);
}

/// Draws the capture screen to the provided `display`.
///
/// Other parameters are from the current [`State`][crate::state::State] and used for display.
pub fn draw_capture(
    display: &mut Display,
    selected: Option<&ShortFileName>,
    running: bool,
    bitrate: &Bitrate,
    silent: bool,
    success_count: u32,
) {
    // Load icons
    let capture_icon =
        Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/capture.bmp")).unwrap();
    let scroll_icon =
        Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/chevrons_vertical.bmp")).unwrap();
    let play_icon = Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/play.bmp")).unwrap();
    let pause_icon = Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/pause.bmp")).unwrap();
    let stop_icon = Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/stop.bmp")).unwrap();

    // Draw header
    let selected: String<16> = if let Some(selected) = selected {
        to_ascii_lowercase(formatted_string::<16>(format_args!("{}", selected)).unwrap())
    } else {
        String::from_str("root").unwrap()
    };
    draw_header(display, &selected, false);
    let _ = Image::new(&capture_icon, Point::zero()).draw(display);

    // Draw hints
    if running {
        draw_center_hint(display, "Stop", -4);
    } else {
        draw_left_hint(display, "Exit");
        draw_center_hint(display, "Start", -7);
        draw_right_hint(display, "Silent");
    }

    // Load capture parameters
    let bitrate_str: String<20> = formatted_string(format_args!(
        "Bitrate:\n   {:4}kbps",
        *bitrate as u32 / 1000
    ))
    .unwrap();
    let silent_str: String<13> = formatted_string(format_args!("Silent: {:}", silent)).unwrap();

    // Draw capture settings
    let _ = Image::new(&scroll_icon, Point::new(5 * 11 - 2, TEXT_LINE_2 - 3)).draw(display);
    let _ = Text::with_text_style(
        &bitrate_str,
        Point::new(0, TEXT_LINE_2),
        SMALL_TEXT_STYLE,
        LEFT_BOTTOM,
    )
    .draw(display);
    let _ = Text::with_text_style(
        &silent_str,
        Point::new(0, TEXT_LINE_3 + 5),
        SMALL_TEXT_STYLE,
        LEFT_BOTTOM,
    )
    .draw(display);

    // Draw capture state icon
    let _ = Image::new(
        if running {
            &pause_icon
        } else if success_count == 0 {
            &play_icon
        } else {
            &stop_icon
        },
        Point::new(DISPLAY_WIDTH as i32 - 16 - 16, 18),
    )
    .draw(display);

    // Draw capture state text
    let state_str: String<16> = if running {
        String::from_str("Listening").unwrap()
    } else if success_count == 0 {
        String::from_str("Standby").unwrap()
    } else {
        formatted_string(format_args!("Saved {}\nframes", success_count % 10000)).unwrap()
    };
    let _ = Text::with_text_style(
        &state_str,
        Point::new(DISPLAY_WIDTH as i32 - 16 / 2 - 16, TEXT_LINE_3 + 4),
        SMALL_TEXT_STYLE,
        CENTER_BOTTOM,
    )
    .draw(display);
}

/// Draws the emission settings to the provided `display`.
///
/// Other parameters are from the current [`State`][crate::state::State] and used for display.
pub fn draw_emission_settings(
    display: &mut Display,
    selected_item: &EmissionSettingsItem,
    bitrate: &Bitrate,
    mode: &EmissionMode,
) {
    // Load icons
    let emit_icon = Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/emit.bmp")).unwrap();
    let right_icon = Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/right.bmp")).unwrap();
    let left_icon = Bmp::<BinaryColor>::from_slice(include_bytes!("./icons/left.bmp")).unwrap();

    // Draw header and hint
    draw_header(display, "Emission Settings", false);
    draw_center_hint(display, "Save", 0);
    let _ = Image::new(&emit_icon, Point::zero()).draw(display);

    // Center on X axis of parameters display
    let val_center = DISPLAY_WIDTH as i32 - 5 * 6 - 5;

    // Draw Bitrate parameter
    let _ = Text::with_text_style(
        "Bitrate:",
        Point::new(1, TEXT_LINE_2),
        DEFAULT_TEXT_STYLE,
        LEFT_BOTTOM,
    )
    .draw(display);
    let _ = Text::with_text_style(
        &formatted_string::<9>(format_args!("{}kbps", *bitrate as u32 / 1000)).unwrap(),
        Point::new(val_center, TEXT_LINE_2),
        DEFAULT_TEXT_STYLE,
        CENTER_BOTTOM,
    )
    .draw(display);

    // Draw mode parameter
    let _ = Text::with_text_style(
        "Mode:",
        Point::new(1, TEXT_LINE_3),
        DEFAULT_TEXT_STYLE,
        LEFT_BOTTOM,
    )
    .draw(display);
    let _ = Text::with_text_style(
        &formatted_string::<9>(format_args!("{:?}", mode)).unwrap(),
        Point::new(val_center, TEXT_LINE_3),
        DEFAULT_TEXT_STYLE,
        CENTER_BOTTOM,
    )
    .draw(display);

    // Draw parameter edition box (box with LEFT and RIGHT hints surrounding selected value)
    let selected_row = match selected_item {
        EmissionSettingsItem::Bitrate => TEXT_LINE_2,
        EmissionSettingsItem::Mode => TEXT_LINE_3,
    };
    let _ = Image::new(
        &left_icon,
        Point::new(val_center - 6 * 5 - 2, selected_row - 11),
    )
    .draw(display);
    let _ = Image::new(
        &right_icon,
        Point::new(val_center + 6 * 4 + 4, selected_row - 11),
    )
    .draw(display);
    let _ = RoundedRectangle::with_equal_corners(
        Rectangle::with_center(
            Point::new(val_center, selected_row - 6),
            Size::new(6 * 11 + 2, 12),
        ),
        Size::new_equal(4),
    )
    .draw_styled(&DEFAULT_STROKE, display);
}
